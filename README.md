# Ubuntu-Server

This will work if no matter how you plan to use Ubuntu-Server. It could be used to quickly secure a Digital Ocean instance for example. It probably can't be in WSL but I'll test that sometime eventually. It can definitely be from your desktop/laptop Ubuntu instance. For me I want to not be strapped to a desk or powercord all the time so I am making my custom built dev PC an Ubuntu Server so I can SSH in using any device I want.

Script files can easily be generated from this README to automate the provisioning process. 

## Getting Started

### Using Desktop Version

If you are not running the server version of Ubuntu the first step is:

```bash
sudo apt install ubuntu-server ssh 
```

### Using Server Version

```bash
ssh root@your_server_ip
```

We'll all need that eventually.

## Firewall

In order to follow along, moving forward add sudo to everything if you're not logged in as root, or log in as root locally `sudo -i` to avoid typing sudo each time.

```bash
ufw app list
```

One of the selections should be OpenSSH so `ufw allow OpenSSH`

At this point the Firewall is blocking everything but Port 22 - this is only half way though.

## SSH Config

At this point use your favorite text editor and open the path below:
```bash
sudo nano /etc/ssh/sshd_config
```

There may be existing lines with some of this informtaion, but everything in the file is commented out so you can feel free to copy and paste these settings.

```bash
Port 22
LoginGraceTime 2m
PermitRootLogin no
StrictModes yes
MaxAuthTries 6
MaxSessions 10
PasswordAuthentication yes
PermitEmptyPasswords no
```

Then we'll want to restart

```bash
sudo systemctl restart sshd
```

Let's test!

Get your ip address using `ip a` . Note you'll want to use the one labeled something like `IPv4 address for en5s0`. If you pick the wrong one, like docker or vbox you'll get connection denied on port 22. So that's cool, I could theoretically ssh directly into my VM if I configure the VM to allow such. For now it's a Vagrant. 

```bash
ssh {username}@{XXX.XXX.X.XX}
``` 

And you should be prompted for a password, if not go back and try again. 

## Security

### Back to Firewall

```bash
sudo ufw block OpenSSH
sudo ufw allow {port} # between 1024 and 32,767
```

### Back to SSH Config

```bash
Port {port}
LoginGraceTime 2m
PermitRootLogin no
StrictModes yes
MaxAuthTries 6
MaxSessions 10
PasswordAuthentication yes
PermitEmptyPasswords no
```

Save and restart. 

```bash
sudo systemctl restart sshd
```

Now you should be able to connect on your preferred port. Though it's pretty insecure to leave password login on, even if you do have a string password that would take today's computers trillions of years to crack.

### RSA Based auth

Do this from your client.

```bash
ssh-keygen -t rsa
ssh-copy-id -p XXXX jasen@localIP
ssh -p XXXX jasen@localIP
```

Do this to your server, in your `sshd_config`

```bash
PasswordAuthentication no
```

followed by `sudo systemctl restart sshd`

Client should continue to default to RSA. Now it'll take trillions of years to crack the string passkey but they will physically have to have my client as well to match the RSA authentication.

### Port Forwarding

This is all fine and dandy if you're at home on your local network. In order to access your server through your router you need to forward that port from your router to your server. This varies on routers.

You can easily determine your outside IP if you're not running a VPN.

With that outside IP, tell the router the port you want, and the local IP of the server, and the router will pass it through.

You can also configure your server to wake up on LAN which can do anything from booting your system from off. If you have your hard drive encrypted, I'm not sure there is a way to make that work - haven't tried.

With encryption I think the computer will sit there waiting for the password. Just never booting. That would prevent any unwanted individuals from booting your system while you're not home. With the system running and hard drive unlocked the wake on LAN could wake up the server from sleeping. 

For safety purposes though it's probably best to be running a VPN on your router and also I'm going to try SSH into my VM inside of the server. This would prevent any unwanted individuals (including myself) to nuke hardware or native environments.

### Two Factor Authentication

```bash
# update and install pwgen and whois
sudo apt update && sudo apt install pwgen whois libpam-pwquality
# save the variable pass from the complex password generated by pwgen
pass=`pwgen --secure --capitalize --numerals --symbols 12 1`
# print the pass, hash it with mkpasswd, and print it for me again
echo $pass | mkpasswd --stdin  --method=sha-512; echo $pass
```

Figure out how to configure PAM. 

```yml
- name: Configure pam_pwquality
  # lineinfile module allows you to change a line in a file or check whether a line exists
  lineinfile:
    # use this file to make changes to validate passwords
    path: "/etc/pam.d/common-password"
    regexp: "pam_pwquality.so"
    # The negative values in the configuration line above inform pam_pwquality that it must have at least “one of” for that category. See the pam_pwquality man page (enter man pam_pwquality) for further details.
    line: "password required pam_pwquality.so minlen=12 lcredit=-1 ucredit=-1 dcredit=-1 ocredit=-1 retry=3 enforce_for_root"
    state: present

    #- name: Limit Password Reuse
    #  lineinfile:
    #    dest: "/etc/pam.d/common-password"
    #    regexp: "remember=5"
    #    line: "password sufficient pam_unix.so use_authtok remember=5"
    #    state: present
```

1. Install the libpam-google-authenticator package.

```bash
sudo apt install libpam-google-authenticator 
```

2. Generate a GoogleAuthenticator config.

```bash
google-authenticator -f -t -d -r 3 -R 30 -w 17 -e 10
```

Save the generated file in /home/{user}/.hidden_file_name if not already.

3. Configure PAM to use GoogleAuthenticator for SSH logins.

```yml
- name: Configure PAM to use GoogleAuthenticator for SSH logins
  lineinfile:
    dest: "/etc/pam.d/sshd"
    line: "auth required pam_google_authenticator.so nullok"
```

4. Set ChallengeResponseAuthentication to Yes.

```yml
- name: Set ChallengeResponseAuthentication to Yes
  lineinfile:
    dest: "/etc/ssh/sshd_config"
    regexp: "^ChallengeResponseAuthentication (yes|no)"
    line: "ChallengeResponseAuthentication yes"
    state: present
```

5. Set Authentication Methods for bender, vagrant, and ubuntu.
6. Restart SSH Server.

```yml
- name: Set Authentication Methods for bender, vagrant, and ubuntu
  blockinfile:
    path: "/etc/ssh/sshd_config"
    block: |
      Match User "ubuntu,vagrant"
          AuthenticationMethods publickey
      Match User "bender,!vagrant,!ubuntu"
          AuthenticationMethods publickey,keyboard-interactive
    state: present
  notify: "Restart SSH Server"
```